{"version":3,"sources":["webpack://[name]/webpack/universalModuleDefinition","webpack://[name]/webpack/bootstrap","webpack://[name]/./lib/search-query-parser.ts"],"names":["root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","stripSurroundingQuotes","val","replace","addQuotes","indexOf","JSON","stringify","stripBackslashes","_s","n1","stringifyResultData","parseResultData","options","prefix","parts","text","push","apply","length","map","join","keywords","forEach","keyword","ranges","range","from","to","str","userOptions","assign","tokenize","alwaysArray","offsets","parseResult","terms","regex","match","exec","term","sepIndex","slice","isExcludedKey","offsetStart","index","offsetEnd","exclude","undefined","isExcludedTerm","values","split","parsedRange","rangeValues","console","error","parseRange","Array","isArray","trim","excludeKey","keys","offset"],"mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,sBAAuB,GAAIH,GACR,iBAAZC,QACdA,QAAQ,uBAAyBD,IAEjCD,EAAK,uBAAyBC,IARhC,CASoB,oBAATK,KAAuBA,KAAOC,MAAO,WAChD,O,YCTE,IAAIC,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUR,QAGnC,IAAIC,EAASK,EAAiBE,GAAY,CACzCC,EAAGD,EACHE,GAAG,EACHV,QAAS,IAUV,OANAW,EAAQH,GAAUI,KAAKX,EAAOD,QAASC,EAAQA,EAAOD,QAASO,GAG/DN,EAAOS,GAAI,EAGJT,EAAOD,QA0Df,OArDAO,EAAoBM,EAAIF,EAGxBJ,EAAoBO,EAAIR,EAGxBC,EAAoBQ,EAAI,SAASf,EAASgB,EAAMC,GAC3CV,EAAoBW,EAAElB,EAASgB,IAClCG,OAAOC,eAAepB,EAASgB,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhEV,EAAoBgB,EAAI,SAASvB,GACX,oBAAXwB,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAepB,EAASwB,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAepB,EAAS,aAAc,CAAE0B,OAAO,KAQvDnB,EAAoBoB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQnB,EAAoBmB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFAxB,EAAoBgB,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOnB,EAAoBQ,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRvB,EAAoB2B,EAAI,SAASjC,GAChC,IAAIgB,EAAShB,GAAUA,EAAO4B,WAC7B,WAAwB,OAAO5B,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAM,EAAoBQ,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRV,EAAoBW,EAAI,SAASiB,EAAQC,GAAY,OAAOjB,OAAOkB,UAAUC,eAAe1B,KAAKuB,EAAQC,IAGzG7B,EAAoBgC,EAAI,GAIjBhC,EAAoBA,EAAoBiC,EAAI,G;;;;;GCjBrD,SAASC,EAAuBC,GAC5B,OAAOA,EAAIC,QAAQ,mBAAoB,IAI3C,SAASC,EAAUF,GACf,OAAOA,EAAIG,QAAQ,MAAS,EAAIC,KAAKC,UAAUL,GAAOA,EAM1D,SAASM,EAAiBN,GACtB,OAAOA,EAAIC,QAAQ,UAAW,CAACM,EAAIC,KAC/B,OAAQA,GACJ,IAAK,KACD,MAAO,KACX,IAAK,IACD,MAAO,KACX,IAAK,GACD,MAAO,GACX,QACI,OAAOA,KA4XvB,SAASC,EAAgEC,EAAmCC,EAAwBC,GAGhI,IAAIC,EAAkB,GAGtB,GAAIH,EAAgBI,KAAM,CACtB,IAAI9B,EAAkB,GACc,iBAAzB0B,EAAgBI,KACvB9B,EAAM+B,KAAKL,EAAgBI,MAE3B9B,EAAM+B,KAAKC,MAAMhC,EAAO0B,EAAgBI,MAGxC9B,EAAMiC,OAAS,GACfJ,EAAME,KAAK/B,EAAMkC,IAAIhB,GAAWgB,IAAIlB,GAAOY,EAASZ,GAAKmB,KAAK,MA4CtE,OAtCIR,EAAQS,UACRT,EAAQS,SAASC,QAASC,IACtB,IAAKZ,EAAgBY,GACjB,OAGJ,IAAItC,EAAuB,GACa,iBAA7B0B,EAAgBY,GACvBtC,EAAM+B,KAAKL,EAAgBY,IAE3BtC,EAAM+B,KAAKC,MAAMhC,EAAO0B,EAAgBY,IAGxCtC,EAAMiC,OAAS,GACfJ,EAAME,KAAKH,EAASU,EAAU,IAAMtC,EAAMkC,IAAIhB,GAAWiB,KAAK,QAMtER,EAAQY,QACRZ,EAAQY,OAAOF,QAASG,IACpB,IAAKd,EAAgBc,GACjB,OAGJ,IAAIxC,EAAS0B,EAAgBc,GAAsBC,KAC/CC,EAAMhB,EAAgBc,GAAsBE,GAC5CA,IACA1C,EAAQA,EAAQ,IAAM0C,GAGtB1C,GACA6B,EAAME,KAAKH,EAASY,EAAQ,IAAMxC,KAKvC6B,E,iDAjZX,iBAAkEc,EAAM,GAAIC,GAGxE,MAOMjB,EAAUlC,OAAOoD,OAPe,CAClCT,SAAU,GACVG,OAAQ,GACRO,UAAU,EACVC,aAAa,EACbC,SAAS,GAEiCJ,GAG9C,GAAwB,GAApBjB,EAAQmB,WAA2C,IAAtBH,EAAIxB,QAAQ,KACzC,OAAOwB,EAGJ,GAAwB,GAApBhB,EAAQmB,UACY,MAApBnB,EAAQS,UAAgD,IAA5BT,EAAQS,SAASH,QAC3B,MAAlBN,EAAQY,QAA4C,IAA1BZ,EAAQY,OAAON,OAI7C,CAGH,IAAIgB,EAAc,CACdtB,QAASA,GAITuB,EAAkB,GAEtB,MAAMC,EAAQ,2GAGd,IAAIC,EACJ,KAAqC,QAA7BA,EAAQD,EAAME,KAAKV,KAAgB,CACvC,IAAIW,EAAOF,EAAM,GACbG,EAAWD,EAAKnC,QAAQ,KAG5B,IAAkB,IAAdoC,EAAiB,CAGjB,IAAIjD,EAAMgD,EAAKE,MAAM,EAAGD,GACpBvC,EAAMsC,EAAKE,MAAMD,EAAW,GAEhC,MAAME,EAA2B,MAAXnD,EAAI,IAEJ,IAAlBmD,IACAnD,EAAMA,EAAIkD,MAAM,IAGpBxC,EAAMD,EAAuBC,GAC7BA,EAAMM,EAAiBN,IAKqB,IAAxCW,EAAQS,SAASjB,QAAQb,GACzB4C,EAAMnB,KAAK,CACPO,QAAShC,EACTN,MAAOgB,EACP0C,YAAaN,EAAMO,MACnBC,UAAWR,EAAMO,MAAQL,EAAKrB,OAC9B4B,QAASJ,KAEgC,IAAtC9B,EAAQY,OAAOpB,QAAQb,GAC9B4C,EAAMnB,KAAK,CACPO,QAAShC,EACTmC,KAAMzB,EACN0B,QAAIoB,EACJJ,YAAaN,EAAMO,MACnBC,UAAWR,EAAMO,MAAQL,EAAKrB,OAC9B4B,QAASJ,IAGbP,EAAMnB,KAAK,CACPD,KAAMwB,EACNI,YAAaN,EAAMO,MACnBC,UAAWR,EAAMO,MAAQL,EAAKrB,OAC9B4B,QAASJ,QAKd,CAEH,MAAMM,EAA6B,MAAZT,EAAK,IAEL,IAAnBS,IACAT,EAAOA,EAAKE,MAAM,IAGtBF,EAAOvC,EAAuBuC,GAC9BA,EAAOhC,EAAiBgC,GAExBJ,EAAMnB,KAAK,CACPD,KAAMwB,EACNI,YAAaN,EAAMO,MACnBC,UAAWR,EAAMO,MAAQL,EAAKrB,OAC9B4B,QAASE,KA+JrB,GAtJAb,EAAMb,QAASiB,IAGX,GAAI,SAAUA,EAGNA,EAAKxB,KAAKG,UAGW,IAAjBqB,EAAKO,SAEsB,MAAvBZ,EAAYY,UACZZ,EAAYY,QAAU,IAIM,MAA5BZ,EAAYY,QAAQ/B,KACnBmB,EAAYY,QAAQ/B,KAAqBC,KAAKuB,EAAKxB,MAEpDmB,EAAYY,QAAQ/B,KAAO,CAACwB,EAAKxB,OAOb,MAApBmB,EAAYnB,KACXmB,EAAYnB,KAAqBC,KAAKuB,EAAKxB,MAE5CmB,EAAYnB,KAAO,CAACwB,EAAKxB,OAKT,IAApBH,EAAQqB,UACmB,MAAvBC,EAAYD,UACZC,EAAYD,QAAU,IAE1BC,EAAYD,QAAQjB,KAAKuB,UAK9B,GAAI,UAAWA,GAGlB,GAAIA,EAAKtD,MAAMiC,OAAQ,CAInB,IAAI+B,EAASV,EAAKtD,MAAMiE,MAAM,MAET,IAAjBX,EAAKO,SAEsB,MAAvBZ,EAAYY,UACZZ,EAAYY,QAAU,IAIoB,MAA1CZ,EAAYY,QAAQP,EAAKhB,SACxBW,EAAYY,QAAQP,EAAKhB,SAAiCP,QAAQiC,GAElEf,EAAYY,QAAQP,EAAKhB,SAAmC0B,GAO3B,MAAlCf,EAAYK,EAAKhB,SAChBW,EAAYK,EAAKhB,SAAiCP,QAAQiC,GAE1Df,EAAYK,EAAKhB,SAAmC0B,GAKrC,IAApBrC,EAAQqB,UACmB,MAAvBC,EAAYD,UACZC,EAAYD,QAAU,IAE1BC,EAAYD,QAAQjB,KAAKuB,UAM9B,GAAI,SAAUA,GAGbA,EAAKb,KAAKR,OAAQ,CAElB,MAAMiC,EAzO1B,SAAoBZ,GAEhB,IAAIa,EAAcb,EAAKW,MAAM,KAG7B,OAA2B,IAAvBE,EAAYlC,OACL,CACHQ,KAAM0B,EAAY,GAClBzB,GAAIyB,EAAY,IAKbA,EAAYlC,OAAS,GAAM,GAClCmC,QAAQC,MAAM,oDAAoDjD,KAAKC,UAAU8C,OAC1E,MAKA,CACH1B,KAAM0B,EAAY,GAClBzB,QAAIoB,GAmNwBQ,CAAWhB,EAAKb,MAEjB,MAAfyB,KAEqB,IAAjBZ,EAAKO,SAEsB,MAAvBZ,EAAYY,UACZZ,EAAYY,QAAU,IAIoB,MAA1CZ,EAAYY,QAAQP,EAAKhB,SACxBW,EAAYY,QAAQP,EAAKhB,SAA+BP,KAAKmC,GAE7DjB,EAAYY,QAAQP,EAAKhB,SAAiC,CAAC4B,IAO1B,MAAlCjB,EAAYK,EAAKhB,SAChBW,EAAYK,EAAKhB,SAA+BP,KAAKmC,GAErDjB,EAAYK,EAAKhB,SAAiC,CAAC4B,IAKpC,IAApBvC,EAAQqB,UACmB,MAAvBC,EAAYD,UACZC,EAAYD,QAAU,IAE1BC,EAAYD,QAAQjB,KAAK,OAAD,wBACjBuB,GACAY,UAaF,IAArBvC,EAAQmB,WACJyB,MAAMC,QAAQvB,EAAYnB,QAC1BmB,EAAYnB,KAAOmB,EAAYnB,KAAKK,KAAK,KAAKsC,QAEvB,MAAvBxB,EAAYY,SAAmBU,MAAMC,QAAQvB,EAAYY,QAAQ/B,QACjEmB,EAAYY,QAAQ/B,KAAOmB,EAAYY,QAAQ/B,KAAKK,KAAK,KAAKsC,UAK1C,IAAxB9C,EAAQoB,YAAuB,CAC/B,IAAK,IAAI2B,KAAczB,EAAYY,QACZ,SAAfa,GACAH,MAAMC,QAAQvB,EAAYY,QAAQa,KACiD,IAAlFzB,EAAYY,QAAQa,GAAmDzC,SACvEgB,EAAYY,QAAQa,GAAkDzB,EAAYY,QAAQa,GAA4C,IAG/I,IAAK,IAAIpE,KAAO2C,EACA,SAAR3C,GAA0B,YAARA,GAA6B,YAARA,GACvCiE,MAAMC,QAAQvB,EAAY3C,KAC0C,IAAnE2C,EAAY3C,GAA4C2B,SACxDgB,EAAY3C,GAA2C2C,EAAY3C,GAA4C,IAK5H,OAAO2C,EAlQC,OAAON,GA4QvB,qBAAsEM,GAGlE,IAAKA,EACD,MAAO,GAIX,GAA2B,iBAAhBA,EACP,OAAOA,EAIX,GAAwC,IAApCxD,OAAOkF,KAAK1B,GAAahB,OACzB,MAAO,GAGX,IAAIJ,EAAkB,GAiCtB,OA9B2B,MAAvBoB,EAAYD,QACZC,EAAYD,QAAQX,QAASuC,IAGrB,SAAUA,EACV/C,EAAME,OAAyB,IAAnB6C,EAAOf,QAAmB,IAAM,IAAM3C,EAAU0D,EAAO9C,OAG5D,UAAW8C,EAClB/C,EAAME,OAAyB,IAAnB6C,EAAOf,QAAmB,IAAM,IAAMe,EAAOtC,QAAU,IAAMpB,EAAU0D,EAAO5E,QAGnF,SAAU4E,GACjB/C,EAAME,OAAyB,IAAnB6C,EAAOf,QAAmB,IAAM,IAAMe,EAAOtC,QAAU,IAAMpB,EAAU0D,EAAOnC,OAAsB,MAAbmC,EAAOlC,GAAc,IAAMxB,EAAU0D,EAAOlC,IAAO,QAO9Jb,EAAQJ,EAAoBwB,EAAaA,EAAYtB,QAAS,IAG1DsB,EAAYY,SACRpE,OAAOkF,KAAK1B,EAAYY,SAAS5B,OAAS,GAC1CJ,EAAME,QAAQN,EAAoBwB,EAAYY,QAASZ,EAAYtB,QAAS,OAKjFE,EAAMM,KAAK","file":"search-query-parser.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"search-query-parser\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"search-query-parser\"] = factory();\n\telse\n\t\troot[\"search-query-parser\"] = factory();\n})((typeof self !== 'undefined' ? self : this), function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/*!\n * search-query-parser.js\n * Copyright(c) 2014-2020\n * MIT Licensed\n */\n\ntype KeywordName = string;\n\ntype RangeName = string;\n\ntype Options<K extends KeywordName, R extends RangeName > = {\n    keywords: readonly K[];\n    ranges: readonly R[];\n    offsets: boolean;\n    alwaysArray: boolean;\n    tokenize: boolean;\n};\n\ntype TextOffset = {\n    text: string;\n};\n\ntype KeywordOffset = {\n    keyword: string;\n    value: string;\n};\n\ntype RangeOffset = {\n    keyword: string;\n    from: string;\n    to?: string;\n};\n\ntype Offset = (TextOffset | KeywordOffset | RangeOffset) & {\n    offsetStart: number;\n    offsetEnd: number;\n    exclude: boolean;\n};\n\ntype TextValue = string;\n\ntype KeywordValue = string;\n\ntype RangeValue = {\n    from: string;\n    to?: string;\n};\n\ntype Result<K extends KeywordName, R extends RangeName> = {\n    options: Options<K, R>,\n    offsets?: Offset[];\n    exclude?: ResultData<K, R>;\n} & ResultData<K, R>;\n\ntype ResultData<K extends KeywordName, R extends RangeName> = {\n    text?: TextValue | TextValue[];\n} & {\n    [L in K]?: KeywordValue | KeywordValue[];\n} & {\n    [S in R]?: RangeValue | RangeValue[];\n};\n\n/**\n * Strips surrounding quotes\n */\nfunction stripSurroundingQuotes(val: string): string {\n    return val.replace(/^\\\"|\\\"$|^\\'|\\'$/g, '');\n}\n\n// Adds quotes around multiple words\nfunction addQuotes(val: string) {\n    return val.indexOf(' ') > - 1 ? JSON.stringify(val) : val;\n}\n\n/**\n * Strips backslashes respecting escapes\n */\nfunction stripBackslashes(val: string): string {\n    return val.replace(/\\\\(.?)/g, (_s, n1) => {\n        switch (n1) {\n            case '\\\\':\n                return '\\\\';\n            case '0':\n                return '\\u0000';\n            case '':\n                return '';\n            default:\n                return n1;\n        }\n    });\n}\n\n/**\n * Parse a range, split it into parts seperated by a dash\n */\nfunction parseRange(term: string): RangeValue|null {\n\n    let rangeValues = term.split('-');\n\n    // When two ends of the range are specified\n    if (rangeValues.length === 2) {\n        return {\n            from: rangeValues[0],\n            to: rangeValues[1]\n        };\n\n    // When pairs of ranges are specified\n    // keyword:XXXX-YYYY,AAAA-BBBB\n    } else if (rangeValues.length % 2 === 0) {\n        console.error(`Cannot parse multiple pairs of ranges as of now '${JSON.stringify(rangeValues)}'`);\n        return null;\n\n    // When only getting a single value,\n    // or an odd number of values\n    } else {\n        return {\n            from: rangeValues[0],\n            to: undefined\n        };\n    }\n}\n\n/**\n * Parses a string to return a processed SearchParserResult\n */\nexport function parse<K extends KeywordName, R extends RangeName>(str = '', userOptions?: Partial<Options<K, R>>) {\n\n    // Merge options with default options\n    const defaultOptions: Options<K, R> = {\n        keywords: [],\n        ranges: [],\n        tokenize: false,\n        alwaysArray: false,\n        offsets: true\n    };\n    const options = Object.assign(defaultOptions, userOptions);\n\n    // When only a simple string is passed, return it\n    if (options.tokenize == false && str.indexOf(':') === -1) {\n        return str;\n\n    // When no keywords or ranges set, treat as a simple string\n    } else if (options.tokenize == false\n           && (options.keywords == null || options.keywords.length === 0)\n           && (options.ranges == null || options.ranges.length === 0)) {\n                return str;\n\n    // Otherwise parse the advanced query syntax\n    } else {\n\n        // Init object to store the query object\n        let parseResult = {\n            options: options\n        } as Result<K, R>;\n\n        // Temporary storage of terms while processing the input string\n        let terms: Offset[] = [];\n\n        const regex = /(\\S+:'(?:[^'\\\\]|\\\\.)*')|(\\S+:\"(?:[^\"\\\\]|\\\\.)*\")|(-?\"(?:[^\"\\\\]|\\\\.)*\")|(-?'(?:[^'\\\\]|\\\\.)*')|\\S+|\\S+:\\S+/g;\n\n        // Primary loop to split apart individual search terms and key/value pairs\n        let match;\n        while ((match = regex.exec(str)) !== null) {\n            let term = match[0];\n            let sepIndex = term.indexOf(':');\n\n            // Term is a key:value pair of some kind\n            if (sepIndex !== -1) {\n\n                // Seperate key and value\n                let key = term.slice(0, sepIndex);\n                let val = term.slice(sepIndex + 1);\n\n                const isExcludedKey = key[0] === '-' ? true : false;\n\n                if (isExcludedKey === true) {\n                    key = key.slice(1);\n                }\n\n                val = stripSurroundingQuotes(val);\n                val = stripBackslashes(val);\n\n                // Make sure that keywords and ranges are defined\n\n                // Divide into keyword, range or non-configured keyword/range (=text)\n                if (options.keywords.indexOf(key as K) !== -1) {\n                    terms.push({\n                        keyword: key,\n                        value: val,\n                        offsetStart: match.index,\n                        offsetEnd: match.index + term.length,\n                        exclude: isExcludedKey\n                    });\n                } else if (options.ranges.indexOf(key as R) !== -1) {\n                    terms.push({\n                        keyword: key,\n                        from: val,\n                        to: undefined,\n                        offsetStart: match.index,\n                        offsetEnd: match.index + term.length,\n                        exclude: isExcludedKey\n                    });\n                } else {\n                    terms.push({\n                        text: term,\n                        offsetStart: match.index,\n                        offsetEnd: match.index + term.length,\n                        exclude: isExcludedKey\n                    });\n                }\n\n            // Term is not a key:value pair, must be text\n            } else {\n\n                const isExcludedTerm = term[0] === '-' ? true : false;\n\n                if (isExcludedTerm === true) {\n                    term = term.slice(1);\n                }\n\n                term = stripSurroundingQuotes(term);\n                term = stripBackslashes(term);\n\n                terms.push({\n                    text: term,\n                    offsetStart: match.index,\n                    offsetEnd: match.index + term.length,\n                    exclude: isExcludedTerm\n                });\n\n            }\n\n        }\n\n        // Secondary looop\n        // Do some more processing of the search terms\n        terms.forEach((term) => {\n\n            // When just a simple term\n            if ('text' in term) {\n\n                // Make sure text is a thing\n                if (term.text.length) {\n\n\n                    if (term.exclude === true) {\n\n                        if (parseResult.exclude == null) {\n                            parseResult.exclude = {};\n                        }\n\n                        // Push text onto existing array or create new array\n                        if (parseResult.exclude.text != null) {\n                            (parseResult.exclude.text as TextValue[]).push(term.text);\n                        } else {\n                            parseResult.exclude.text = [term.text];\n                        }\n\n                    // Not an exclusion\n                    } else {\n\n                        // Push text onto existing array or create new array\n                        if (parseResult.text != null) {\n                            (parseResult.text as TextValue[]).push(term.text);\n                        } else {\n                            parseResult.text = [term.text];\n                        }\n                    }\n\n                    // When offsets is true, we also add it to the offsets array\n                    if (options.offsets === true) {\n                        if (parseResult.offsets == null) {\n                            parseResult.offsets = [];\n                        }\n                        parseResult.offsets.push(term);\n                    }\n                }\n\n            // Keyword\n            } else if ('value' in term) {\n\n                // Make sure value is a thing\n                if (term.value.length) {\n\n                    // Get an array of values when several are there\n                    // or turn into array if it's only one value anyway\n                    let values = term.value.split(',');\n\n                    if (term.exclude === true) {\n\n                        if (parseResult.exclude == null) {\n                            parseResult.exclude = {};\n                        }\n\n                        // Push values onto existing array or create new array\n                        if (parseResult.exclude[term.keyword as K] != null) {\n                            (parseResult.exclude[term.keyword as K] as KeywordValue[]).push(...values);\n                        } else {\n                            (parseResult.exclude[term.keyword as K] as KeywordValue[]) = values;\n                        }\n\n                    // Not an exclusion\n                    } else {\n\n                        // Push values onto existing array or create new array\n                        if (parseResult[term.keyword as K] != null) {\n                            (parseResult[term.keyword as K] as KeywordValue[]).push(...values);\n                        } else {\n                            (parseResult[term.keyword as K] as KeywordValue[]) = values;\n                        }\n                    }\n\n                    // When offsets is true, we also add it to the offsets array\n                    if (options.offsets === true) {\n                        if (parseResult.offsets == null) {\n                            parseResult.offsets = [];\n                        }\n                        parseResult.offsets.push(term);\n                    }\n\n                }\n\n            // Range\n            } else if ('from' in term) {\n\n                // Make sure from is a thing\n                if (term.from.length) {\n\n                    const parsedRange = parseRange(term.from);\n\n                    if (parsedRange != null) {\n\n                        if (term.exclude === true) {\n\n                            if (parseResult.exclude == null) {\n                                parseResult.exclude = {};\n                            }\n\n                            // Push values onto existing array or create new array\n                            if (parseResult.exclude[term.keyword as R] != null) {\n                                (parseResult.exclude[term.keyword as R] as RangeValue[]).push(parsedRange);\n                            } else {\n                                (parseResult.exclude[term.keyword as R] as RangeValue[]) = [parsedRange];\n                            }\n\n                        // Not an exclusion\n                        } else {\n\n                            // Push values onto existing array or create new array\n                            if (parseResult[term.keyword as R] != null) {\n                                (parseResult[term.keyword as R] as RangeValue[]).push(parsedRange);\n                            } else {\n                                (parseResult[term.keyword as R] as RangeValue[]) = [parsedRange];\n                            }\n                        }\n\n                        // When offsets is true, we also add it to the offsets array\n                        if (options.offsets === true) {\n                            if (parseResult.offsets == null) {\n                                parseResult.offsets = [];\n                            }\n                            parseResult.offsets.push({\n                                ...term,\n                                ...parsedRange // overrides term.from & term.to\n                            });\n                        }\n\n                    }\n\n                }\n\n            }\n\n        });\n\n        // If tokenize is false, concatenate text terms\n        if (options.tokenize === false) {\n            if (Array.isArray(parseResult.text)) {\n                parseResult.text = parseResult.text.join(' ').trim();\n            }\n            if (parseResult.exclude != null && Array.isArray(parseResult.exclude.text)) {\n                parseResult.exclude.text = parseResult.exclude.text.join(' ').trim();\n            }\n        }\n\n        // If alwaysArray is false, flatten out non-text (keyword and array) arrays if there is only one occurence\n        if (options.alwaysArray === false) {\n            for (let excludeKey in parseResult.exclude) {\n                if (excludeKey !== 'text'\n                 && Array.isArray(parseResult.exclude[excludeKey as K|R])\n                 && (parseResult.exclude[excludeKey as K|R] as (KeywordValue|RangeValue)[]).length === 1) {\n                    (parseResult.exclude[excludeKey as K|R] as KeywordValue|RangeValue) = (parseResult.exclude[excludeKey] as (KeywordValue|RangeValue)[])[0];\n                }\n            }\n            for (let key in parseResult) {\n                if (key !== 'text' && key !== 'exclude' && key !== 'offsets'\n                 && Array.isArray(parseResult[key as K|R])\n                 && (parseResult[key as K|R] as (KeywordValue|RangeValue)[]).length === 1) {\n                    (parseResult[key as K|R] as KeywordValue|RangeValue) = (parseResult[key as K|R] as (KeywordValue|RangeValue)[])[0];\n                }\n            }\n        }\n\n        return parseResult;\n    }\n\n}\n\n/**\n/**\n * Turns a previous parseResult back into a string.\n * This requires that the original `parse()` method used `options.offsets: true` in order to respect its sort order.\n */\nexport function stringify<K extends KeywordName, R extends RangeName>(parseResult: Result<K, R> | string) {\n\n    // If the query object is falsy we can just return an empty string\n    if (!parseResult) {\n        return '';\n    }\n\n    // If the query object is already a string, we can return it immediately\n    if (typeof parseResult === 'string') {\n        return parseResult;\n    }\n\n    // If the query object does not have any keys, we can return an empty string\n    if (Object.keys(parseResult).length === 0) {\n        return '';\n    }\n\n    let parts: string[] = [];\n\n    // If the parseResult has an offsets array use that to keep the original sort order\n    if (parseResult.offsets != null) {\n        parseResult.offsets.forEach((offset) => {\n\n            // TextOffset\n            if ('text' in offset) {\n                parts.push((offset.exclude === true ? '-' : '') + addQuotes(offset.text));\n\n            // KeywordOffset\n            } else if ('value' in offset) {\n                parts.push((offset.exclude === true ? '-' : '') + offset.keyword + ':' + addQuotes(offset.value));\n\n            // RangeOffset\n            } else if ('from' in offset) {\n                parts.push((offset.exclude === true ? '-' : '') + offset.keyword + ':' + addQuotes(offset.from) + (offset.to != null ? ('-' + addQuotes(offset.to)) : ''));\n            }\n        });\n\n    } else {\n\n        // Otherwise start by stringifying the positive text, keyword and ranges\n        parts = stringifyResultData(parseResult, parseResult.options, '');\n\n        // Add in excluded text keywords and ranges\n        if (parseResult.exclude) {\n            if (Object.keys(parseResult.exclude).length > 0) {\n                parts.push(...stringifyResultData(parseResult.exclude, parseResult.options, '-'));\n            }\n        }\n    }\n\n    return parts.join(' ');\n\n}\n\nfunction stringifyResultData<K extends KeywordName, R extends RangeName>(parseResultData: ResultData<K, R>, options: Options<K, R>, prefix: string) {\n\n    // Keep track of all single stringified parts in this array\n    let parts: string[] = [];\n\n    // Text\n    if (parseResultData.text) {\n        let value: string[] = [];\n        if (typeof parseResultData.text === 'string') {\n            value.push(parseResultData.text);\n        } else {\n            value.push.apply(value, parseResultData.text);\n        }\n\n        if (value.length > 0) {\n            parts.push(value.map(addQuotes).map(val => prefix + val).join(' '));\n        }\n    }\n\n\n    // Keywords\n    if (options.keywords) {\n        options.keywords.forEach((keyword) => {\n            if (!parseResultData[keyword]) {\n                return;\n            }\n\n            let value: KeywordValue[]= [];\n            if (typeof parseResultData[keyword] === 'string') {\n                value.push(parseResultData[keyword] as KeywordValue);\n            } else {\n                value.push.apply(value, parseResultData[keyword] as KeywordValue[]);\n            }\n\n            if (value.length > 0) {\n                parts.push(prefix + keyword + ':' + value.map(addQuotes).join(','));\n            }\n        });\n    }\n\n    // Ranges\n    if (options.ranges) {\n        options.ranges.forEach((range) => {\n            if (!parseResultData[range]) {\n                return;\n            }\n\n            let value = (parseResultData[range] as RangeValue).from;\n            let to = (parseResultData[range] as RangeValue).to;\n            if (to) {\n                value = value + '-' + to;\n            }\n\n            if (value) {\n                parts.push(prefix + range + ':' + value);\n            }\n        });\n    }\n\n    return parts;\n}\n\n"],"sourceRoot":""}